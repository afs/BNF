options
{
    // \ u processed after parsing in strings and IRIs, nowhere else.
    JAVA_UNICODE_ESCAPE   = false ;
    UNICODE_INPUT         = true ;

  STATIC                = false ;
//   DEBUG_PARSER          = true ;
//   DEBUG_TOKEN_MANAGER   = true ;
}

PARSER_BEGIN(EBNFParser)

package org.seaborne.bnf.parser.javacc;

import org.seaborne.bnf.parser.*;

public class EBNFParser extends BNFParser {}

PARSER_END(EBNFParser)

// SPECIAL_TOKEN:

SKIP : { <LINE_COMMENT: "//" (~["\n","\r"])* > }
// Conflicts with hex character
//SKIP : { <HASH_COMMENT: "#" (~["\n","\r"])* > }

//SKIP :  { " " | "\t" | "\r" | "\n" }


// SKIP : { <WS: " " | "\t" | "\r" | "\n" > }

// Horizontal whitespace
SKIP : {  <WSP: (" " | "\t")> }


TOKEN : {
  < EOL: ("\r")? "\n" >   // Not Mac OS 9, which was 2001.
//| <LF: "\r" >             // 0x0A - 10 - NL (if single character)
//| <CR: "\n" >             // 0x0D - 13

|  < ASSIGN:  "::=" >
|  < OR:      "|" >
|  < STAR:    "*" >
|  < PLUS:    "+" >
|  < QUERY:   "?" >
|  < LPAREN:  "(" >
|  < RPAREN:  ")" >
|  < LBRACK:  "[" >
|  < RBRACK:  "]" >
|  < LBRACE:  "{" >
|  < RBRACE:  "}" >
|  < SEMI:    ";" >
|  < DOT:     "." >
// 0x5E ASCII and Common name: Unicode: Circumflex Accent
|  < CARAT:   "^" >    

|  < NONTERMINAL:    "<" (~[">", "\n", "\r"])* ">" >

|  < ECHAR:          "\\" ( "t"|"b"|"n"|"r"| "\\"|"\""|"'") >
|  < #HEX:           ["0"-"9"] | ["A"-"F"] | ["a"-"f"] >
|  < #UCHAR:         <UCHAR4> | <UCHAR8> >
|  < #UCHAR4:        "\\" "u" <HEX> <HEX> <HEX> <HEX> >
|  < #UCHAR8:        "\\" "U" <HEX> <HEX> <HEX> <HEX> <HEX> <HEX> <HEX> <HEX> >

// Single character.
// |  < RANGE_CHAR:     (~["'","\\","\n","\r"]) | <ECHAR> | <UCHAR> >

|  < QUOTED_STRING:  <QSTRING1> | <QSTRING2> >
|  < QSTRING1:       ( "'" ( (~["'","\\","\n","\r"]) | <ECHAR> | <UCHAR> )* "'" ) >
|  < QSTRING2:       ( "\"" ( (~["\"","\\","\n","\r"]) | <ECHAR> | <UCHAR> )* "\"" ) >

//|  <LABEL: <LBRACK> (~["\n","\r"])* <RBRACK> >

// Needs work for i18n. Exclude surrogates, U+FFFE, U+FFFF
// May be only BMP (java)
|  < #AZ : (["A"-"Z"] | ["a"-"z"]) >
|  < #DIGITS:  ["0"-"9"] >
|  < INTEGER: (<DIGITS>)+ >
|  < #AZN : ( <AZ> | <DIGITS> ) >

|  < HEX_CHAR: "#x" (<HEX>)+ >

// Last
|  < WORD:  <AZ> (("_" | <AZN> )* <AZN> )? >
}

void Unit() : {} { Grammar() }

void EOL() : {} { <EOL> }

void Grammar() : { Rule rule; }
{
  BlankLines()
  { startGrammar(); }
  (
    rule = Rule() { emitRule(rule); }
    BlankLines()
  )*
  <EOF>
  { finishGrammar(); }
}

Rule Rule() : { Identifier identifier ; Expression expr; Rule rule; String label = null; }
{
    { startRule(); }
    (label = Label())?
    identifier = Identifier()
    <ASSIGN>
    expr = Expression()
    (EOL()|<EOF>)
    { rule = createRule(label, identifier, expr);
      finishRule(); }
    { return rule; }
}

void BlankLines() : {} {
   (EOL())*
}

String Label() : { String str = ""; }
{
     <LBRACK>
     ( str = Integer()
     | str = Word()
     )?
     <RBRACK>
     { return str; }
}

// LHS
Identifier Identifier() : { Token t; String str;}
{
    (
      t = <NONTERMINAL> { return createNonTerminal(t.image); }
    |
      str = Word()      { return createWord(str); }
    )
 }

Expression Expression() : { Expression expr;}
{
     { startExpression() ; } 
     expr = Alternatives()

     { finishExpression() ; }
     { return expr; }
}

Expression Alternatives() : { Expression expr ; }
{
    { startAlternatives() ; } 
    expr = Sequence() { emitAlternativesElement(expr); }
    (
       <OR>
       expr = Sequence() { emitAlternativesElement(expr); }
    )*
    { expr = collectedAlternatives(); }
    { finishAlternatives() ; }
    { return expr; }
}

// At least one element.
Expression Sequence() : { Expression expr; }
{
    { startSequence() ; }
    (
      expr = Unary() { emitSequenceElement(expr); }
    )+
    
    { expr = collectedSequence();
      finishSequence() ;
      return expr; }
}

Expression Unary() : { Expression expr; Token mod = null; }
{
    expr = Primary()
      ( 
        ( mod = <QUERY> { expr = createExprZeroOrOne(expr); }
        | mod = <STAR>  { expr = createExprZeroOrMore(expr); }
        | mod = <PLUS>  { expr = createExprOneOrMore(expr); }
        )
      )?
    { return expr; }
}

Expression Primary() : { String str; Token t; Expression expr; }
{
    (
      t = <NONTERMINAL> { return createNonTerminal(t.image); }
    |
      str = Word()      { return createWord(str); }
    |
      t = <QUOTED_STRING> { return createQuotedString(t.image); }
      // CharacterRange, CharacterNumericRange
    |
      <LPAREN> expr = Expression() <RPAREN> { return createPrimary(expr); }
      // Other {} []
      // [] - ABNF optional, ISO EBNF
//     |
//       // Alterative to "()"
//       // BNF++ - zero or more.
//       <LBRACE> expr = Expression() <RBRACE> { return expr; }
    |
      expr = Character() { return expr; }
    |
      expr = CharacterRange() { return expr; }
    )
}

Expression Character() : { Token t; }
{
   t = <HEX_CHAR> { return createCharacter(t.image); }
}

Expression CharacterRange() : { String s1; String s2; boolean isNegative = false; }
{
    <LBRACK>
    ( <CARAT> { isNegative = true; } )?
    s1 = RangeElement()
    "-"
    s2 = RangeElement()
    <RBRACK>
    { return createCharacterRange(s1, s2, isNegative); }
}

String RangeElement() : { String str; }
{
  ( str = HexChar() { return str; }
  // later: Parse lexical state to switch to a different set of lexical tokens
  | str = Word()   { return wordToRangeChar(str, token.beginLine, token.beginColumn); }
  | str = Integer()  { return wordToRangeChar(str, token.beginLine, token.beginColumn); }
  )
}

// Abstract away from the concrete token.

// String WS() : { }
// {
// }



String HexChar() : { Token t; String str; }
{
    t = <HEX_CHAR>
    { return t.image; }
}


String Word() : { Token t; String str; }
{
    t = <WORD>
    { return t.image; }
}

String Integer() : { Token t; String str; }
{
    t = <INTEGER>
    { return t.image; }
}




//   [a-zA-Z], [#xN-#xN]
//   [abc], [#xN#xN#xN]
//   [^a-z], [^#xN-#xN]
//   [^abc], [^#xN#xN#xN]

/*
# Local Variables:
# tab-width: 4
# indent-tabs-mode: nil
# comment-default-style: "//"
# End:
*/
